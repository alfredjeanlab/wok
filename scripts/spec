#!/bin/bash
# Run BATS specs with automatic bats detection
#
# Usage: scripts/spec [suite] [options]
#
# Suites:
#   (none)     Run all specs
#   cli        Run CLI specs only
#   remote     Run remote specs only
#
# Options:
#   --filter <regex>   Filter tests by name
#   --file <path>      Run specific test file (relative to checks/specs/)
#   --filter-tags <t>  Filter by bats tags (e.g., todo:implement)
#   --timeout <secs>   Test timeout in seconds (default: 5)
#   --parallel, -p     Run tests in parallel (80% of CPUs, min 1)
#
# Examples:
#   scripts/spec --filter "short flag"      # Run tests matching "short flag"
#   scripts/spec --file cli/unit/list.bats  # Run specific test file
#   scripts/spec cli --filter "list"        # Run CLI tests matching "list"
#
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
ROOT_DIR="$(dirname "$SCRIPT_DIR")"
SPECS_DIR="$ROOT_DIR/checks/specs"
BATS_LOCAL_DIR="$SPECS_DIR/bats"

# Initialize bats submodules if needed
if [ ! -f "$BATS_LOCAL_DIR/bats-support/load.bash" ]; then
    if [ -x "$BATS_LOCAL_DIR/install.sh" ]; then
        echo "Initializing bats libraries..."
        "$BATS_LOCAL_DIR/install.sh"
    fi
fi

# Always use local bats for consistent behavior across environments
BATS="$BATS_LOCAL_DIR/bats-core/bin/bats"

# Find bats library path (support/assert)
export BATS_LIB_PATH=""
for p in /usr/local/lib /opt/homebrew/lib /usr/lib; do
    if [ -d "$p/bats-support" ] && [ -d "$p/bats-assert" ]; then
        export BATS_LIB_PATH="$p"
        break
    fi
done

# Fall back to local libraries
if [ -z "$BATS_LIB_PATH" ]; then
    export BATS_LIB_PATH="$BATS_LOCAL_DIR"
fi

# Verify bats is available
if [ ! -x "$BATS" ]; then
    echo "Error: bats not found at $BATS" >&2
    exit 1
fi

# Verify bats libraries are available
if [ ! -f "$BATS_LIB_PATH/bats-support/load.bash" ]; then
    echo "Error: bats libraries not found at $BATS_LIB_PATH" >&2
    exit 1
fi

# Default binary paths - auto-detect from build output or fall back to PATH
if [ -z "${WK_BIN:-}" ]; then
    if [ -x "$ROOT_DIR/target/release/wk" ]; then
        export WK_BIN="$ROOT_DIR/target/release/wk"
    elif [ -x "$ROOT_DIR/target/debug/wk" ]; then
        export WK_BIN="$ROOT_DIR/target/debug/wk"
    else
        export WK_BIN="wk"
    fi
fi

if [ -z "${WK_REMOTE_BIN:-}" ]; then
    if [ -x "$ROOT_DIR/target/release/wk-remote" ]; then
        export WK_REMOTE_BIN="$ROOT_DIR/target/release/wk-remote"
    elif [ -x "$ROOT_DIR/target/debug/wk-remote" ]; then
        export WK_REMOTE_BIN="$ROOT_DIR/target/debug/wk-remote"
    else
        export WK_REMOTE_BIN="wk-remote"
    fi
fi

# Default test timeout (seconds) - prevents hung tests from blocking CI
DEFAULT_TIMEOUT=5

# Detect CPU count cross-platform (returns 1 on failure)
detect_cpus() {
    local cpus=1
    if command -v nproc >/dev/null 2>&1; then
        cpus=$(nproc 2>/dev/null) || cpus=1
    elif command -v sysctl >/dev/null 2>&1; then
        cpus=$(sysctl -n hw.ncpu 2>/dev/null) || cpus=1
    elif [ -f /proc/cpuinfo ]; then
        cpus=$(grep -c ^processor /proc/cpuinfo 2>/dev/null) || cpus=1
    fi
    # Ensure valid positive integer
    if ! [[ "$cpus" =~ ^[0-9]+$ ]] || [ "$cpus" -lt 1 ]; then
        echo "Warning: Could not detect CPU count, defaulting to 1" >&2
        cpus=1
    fi
    echo "$cpus"
}

# Calculate parallel jobs: 80% of CPUs, minimum 1
calc_parallel_jobs() {
    local cpus
    cpus=$(detect_cpus)
    local jobs=$(( cpus * 80 / 100 ))
    [ "$jobs" -lt 1 ] && jobs=1
    echo "$jobs"
}

# Parse arguments
SUITE=""
FILE=""
PARALLEL=""
BATS_ARGS=()

while [ $# -gt 0 ]; do
    case "$1" in
        cli|cli/)
            SUITE="cli"
            shift
            ;;
        remote|remote/)
            SUITE="remote"
            shift
            ;;
        --file)
            FILE="$2"
            shift 2
            ;;
        --timeout)
            DEFAULT_TIMEOUT="$2"
            shift 2
            ;;
        --parallel|-p)
            PARALLEL="auto"
            shift
            ;;
        *)
            BATS_ARGS+=("$1")
            shift
            ;;
    esac
done

# Add parallel jobs (remote tests excluded - port conflicts)
if [ "$SUITE" = "remote" ]; then
    # Force sequential for remote tests regardless of --parallel flag
    BATS_ARGS+=("--jobs" "1")
    # Use longer timeout for remote tests (network operations)
    DEFAULT_TIMEOUT=10
elif [ "$PARALLEL" = "auto" ]; then
    JOBS=$(calc_parallel_jobs)
    BATS_ARGS+=("--jobs" "$JOBS")
    echo "Parallel: $JOBS jobs (80% of $(detect_cpus) CPUs)"
fi

# Build test targets
if [ -n "$FILE" ]; then
    # Specific file mode
    if [[ "$FILE" = /* ]]; then
        TARGETS=("$FILE")
    else
        TARGETS=("$SPECS_DIR/$FILE")
    fi
else
    # Suite mode
    case "$SUITE" in
        cli)
            TARGETS=("$SPECS_DIR/cli/unit" "$SPECS_DIR/cli/integration" "$SPECS_DIR/cli/edge_cases")
            ;;
        remote)
            TARGETS=("$SPECS_DIR/remote/unit" "$SPECS_DIR/remote/integration" "$SPECS_DIR/remote/edge_cases")
            ;;
        *)
            TARGETS=(
                "$SPECS_DIR/cli/unit" "$SPECS_DIR/cli/integration" "$SPECS_DIR/cli/edge_cases"
                "$SPECS_DIR/remote/unit" "$SPECS_DIR/remote/integration" "$SPECS_DIR/remote/edge_cases"
            )
            ;;
    esac
fi

echo "BATS: $BATS"
echo "BATS_LIB_PATH: $BATS_LIB_PATH"
echo "WK_BIN: $WK_BIN"
echo "WK_REMOTE_BIN: $WK_REMOTE_BIN"
echo ""

# Export timeout for bats to enforce
export BATS_TEST_TIMEOUT="$DEFAULT_TIMEOUT"

exec "$BATS" --recursive --timing "${BATS_ARGS[@]+"${BATS_ARGS[@]}"}" "${TARGETS[@]}"
