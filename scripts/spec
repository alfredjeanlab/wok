#!/bin/bash
# Run BATS specs with automatic bats detection
#
# Usage: scripts/spec [suite] [options]
#
# Suites:
#   (none)     Run all specs
#   cli        Run CLI specs only
#   remote     Run remote specs only
#
# Options:
#   --filter <regex>   Filter tests by name
#   --file <path>      Run specific test file (relative to tests/specs/)
#   --filter-tags <t>  Filter by bats tags (e.g., todo:implement)
#   --timeout <secs>   Test timeout in seconds (default: 5)
#   --parallel, -p     Run tests in parallel (80% of CPUs, min 1)
#
# Examples:
#   scripts/spec --filter "short flag"      # Run tests matching "short flag"
#   scripts/spec --file cli/unit/list.bats  # Run specific test file
#   scripts/spec cli --filter "list"        # Run CLI tests matching "list"
#
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
ROOT_DIR="$(dirname "$SCRIPT_DIR")"
SPECS_DIR="$ROOT_DIR/tests/specs"

# BATS configuration (global installation to user data directory)
WK_DATA_DIR="${XDG_DATA_HOME:-$HOME/.local/share}/wok"
BATS_DIR="$WK_DATA_DIR/bats"
BATS="$BATS_DIR/bats-core/bin/bats"
export BATS_LIB_PATH="$BATS_DIR"

# BATS versions
BATS_CORE_VERSION="v1.11.0"
BATS_SUPPORT_VERSION="v0.3.0"
BATS_ASSERT_VERSION="v2.1.0"

# Download and extract a BATS component
download_bats_component() {
    local repo="$1"
    local version="$2"
    local target="$3"
    local url="https://github.com/bats-core/${repo}/archive/refs/tags/${version}.tar.gz"
    local temp_file
    temp_file=$(mktemp)

    echo "Downloading $repo $version..."
    if command -v curl >/dev/null 2>&1; then
        curl -fsSL "$url" -o "$temp_file"
    elif command -v wget >/dev/null 2>&1; then
        wget -q "$url" -O "$temp_file"
    else
        echo "Error: curl or wget required to download BATS" >&2
        rm -f "$temp_file"
        exit 1
    fi

    # Extract to target directory
    mkdir -p "$BATS_DIR"
    tar -xzf "$temp_file" -C "$BATS_DIR"
    rm -f "$temp_file"

    # Rename extracted directory (removes version suffix)
    local extracted_dir="$BATS_DIR/${repo}-${version#v}"
    if [ -d "$extracted_dir" ]; then
        rm -rf "$BATS_DIR/$target"
        mv "$extracted_dir" "$BATS_DIR/$target"
    fi

    echo "$repo installed to $BATS_DIR/$target"
}

# Ensure BATS and its libraries are installed
ensure_bats_installed() {
    if [ -d "$BATS_DIR/bats-support" ] && [ -d "$BATS_DIR/bats-assert" ] && [ -x "$BATS" ]; then
        return 0
    fi

    echo "Installing BATS libraries to $BATS_DIR..."
    mkdir -p "$BATS_DIR"

    [ -x "$BATS" ] || download_bats_component "bats-core" "$BATS_CORE_VERSION" "bats-core"
    [ -d "$BATS_DIR/bats-support" ] || download_bats_component "bats-support" "$BATS_SUPPORT_VERSION" "bats-support"
    [ -d "$BATS_DIR/bats-assert" ] || download_bats_component "bats-assert" "$BATS_ASSERT_VERSION" "bats-assert"

    echo "BATS installation complete!"
    echo ""
}

ensure_bats_installed

# Default binary paths - auto-detect from build output or fall back to PATH
if [ -z "${WK_BIN:-}" ]; then
    if [ -x "$ROOT_DIR/target/release/wk" ]; then
        export WK_BIN="$ROOT_DIR/target/release/wk"
    elif [ -x "$ROOT_DIR/target/debug/wk" ]; then
        export WK_BIN="$ROOT_DIR/target/debug/wk"
    else
        export WK_BIN="wk"
    fi
fi

if [ -z "${WK_REMOTE_BIN:-}" ]; then
    if [ -x "$ROOT_DIR/target/release/wk-remote" ]; then
        export WK_REMOTE_BIN="$ROOT_DIR/target/release/wk-remote"
    elif [ -x "$ROOT_DIR/target/debug/wk-remote" ]; then
        export WK_REMOTE_BIN="$ROOT_DIR/target/debug/wk-remote"
    else
        export WK_REMOTE_BIN="wk-remote"
    fi
fi

# Default test timeout (seconds) - prevents hung tests from blocking CI
DEFAULT_TIMEOUT=5

# Detect CPU count cross-platform (returns 1 on failure)
detect_cpus() {
    local cpus=1
    if command -v nproc >/dev/null 2>&1; then
        cpus=$(nproc 2>/dev/null) || cpus=1
    elif command -v sysctl >/dev/null 2>&1; then
        cpus=$(sysctl -n hw.ncpu 2>/dev/null) || cpus=1
    elif [ -f /proc/cpuinfo ]; then
        cpus=$(grep -c ^processor /proc/cpuinfo 2>/dev/null) || cpus=1
    fi
    # Ensure valid positive integer
    if ! [[ "$cpus" =~ ^[0-9]+$ ]] || [ "$cpus" -lt 1 ]; then
        echo "Warning: Could not detect CPU count, defaulting to 1" >&2
        cpus=1
    fi
    echo "$cpus"
}

# Calculate parallel jobs: 80% of CPUs, minimum 1
calc_parallel_jobs() {
    local cpus
    cpus=$(detect_cpus)
    local jobs=$(( cpus * 80 / 100 ))
    [ "$jobs" -lt 1 ] && jobs=1
    echo "$jobs"
}

# Parse arguments
SUITE=""
FILE=""
PARALLEL=""
BATS_ARGS=()

while [ $# -gt 0 ]; do
    case "$1" in
        cli|cli/)
            SUITE="cli"
            shift
            ;;
        remote|remote/)
            SUITE="remote"
            shift
            ;;
        --file)
            FILE="$2"
            shift 2
            ;;
        --timeout)
            DEFAULT_TIMEOUT="$2"
            shift 2
            ;;
        --parallel|-p)
            PARALLEL="auto"
            shift
            ;;
        *)
            BATS_ARGS+=("$1")
            shift
            ;;
    esac
done

# Add parallel jobs (remote tests excluded - port conflicts)
if [ "$SUITE" = "remote" ]; then
    # Force sequential for remote tests regardless of --parallel flag
    BATS_ARGS+=("--jobs" "1")
    # Use longer timeout for remote tests (network operations)
    DEFAULT_TIMEOUT=10
elif [ "$PARALLEL" = "auto" ]; then
    JOBS=$(calc_parallel_jobs)
    BATS_ARGS+=("--jobs" "$JOBS")
    echo "Parallel: $JOBS jobs (80% of $(detect_cpus) CPUs)"
fi

# Build test targets
if [ -n "$FILE" ]; then
    # Specific file mode
    if [[ "$FILE" = /* ]]; then
        TARGETS=("$FILE")
    else
        TARGETS=("$SPECS_DIR/$FILE")
    fi
else
    # Suite mode
    case "$SUITE" in
        cli)
            TARGETS=("$SPECS_DIR/cli/unit" "$SPECS_DIR/cli/integration" "$SPECS_DIR/cli/edge_cases")
            ;;
        remote)
            TARGETS=("$SPECS_DIR/remote/unit" "$SPECS_DIR/remote/integration" "$SPECS_DIR/remote/edge_cases")
            ;;
        *)
            TARGETS=(
                "$SPECS_DIR/cli/unit" "$SPECS_DIR/cli/integration" "$SPECS_DIR/cli/edge_cases"
                "$SPECS_DIR/remote/unit" "$SPECS_DIR/remote/integration" "$SPECS_DIR/remote/edge_cases"
            )
            ;;
    esac
fi

echo "BATS: $BATS"
echo "BATS_LIB_PATH: $BATS_LIB_PATH"
echo "WK_BIN: $WK_BIN"
echo "WK_REMOTE_BIN: $WK_REMOTE_BIN"
echo ""

# Export timeout for bats to enforce
export BATS_TEST_TIMEOUT="$DEFAULT_TIMEOUT"

exec "$BATS" --recursive --timing "${BATS_ARGS[@]+"${BATS_ARGS[@]}"}" "${TARGETS[@]}"
